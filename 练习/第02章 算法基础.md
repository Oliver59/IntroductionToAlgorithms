# 第二章 算法基础 练习

## 2.1
![](https://raw.githubusercontent.com/Oliver59/IntroductionToAlgorithms/master/%E7%BB%83%E4%B9%A0/Image/2.1.png)
### 2.1-1

答：![](https://raw.githubusercontent.com/Oliver59/IntroductionToAlgorithms/master/%E7%BB%83%E4%B9%A0/Image/2.1-1.png)


### 2.1-2
答：
```
INSERTION-SORT(A)
	for j=2 to A.Length
		key = A[j]
		i = j - 1
		while i > 0 and A[i] < key
			A[i+1] = A[i]		
			i = i - 1
		A[i + 1] = key
```

### 2.1-3
答：
```
SEARCH(A, v):
	for i = 1 to n
		if A[i] = v
			return i
		i = i + 1
	return NIL
```

### 2.1-4
答：
```
ADD-BINARY(A, B):
C = new integer[A.length + 1]//数组C的长度为N+1
	flag=false
	i = n
	while  i > 1
		if flag=true 
			if A[i]==1 and B[i]==1
				flag=true
				C[i+1]=1
			else 
				if A[i]==1 or B[i]==1
					flag=true
					C[i+1]=0
				else 
					C[i+1]=1	
		else
			if A[i]==1 and B[i]==1
				flag=true
				C[i+1]=0
			else 
				flag=false
				if A[i]==1 or B[i]==1
					C[i+1]=1
				else 
					C[i+1]=0
		i--
	
	if flag=true 
		C[1]=1
	else 
		C[1]=0
return C
```
大牛答案：
```
ADD-BINARY(A, B):
  C = new integer[A.length + 1]

  carry = 0
  for i = 1 to A.length
      C[i] = (A[i] + B[i] + carry) % 2  // remainder
      carry = (A[i] + B[i] + carry) / 2 // quotient
  C[i] = carry

  return C
```

## 2.2
![](https://raw.githubusercontent.com/Oliver59/IntroductionToAlgorithms/master/%E7%BB%83%E4%B9%A0/Image/2.2.png)

### 2.2-1
Θ(n³)

### 2.2-2
伪代码：
```
SELECTION-SORT(A)
	for i=1 to n
		index = i 
		j = i + 1
		while j <= n
			if A[index] > A [j]
				index = j
			j = j +1
		if index != i
			key = A[index]
			A[index] = A[i]
			A[i] = key
```
最好情况：θ(n²)
最坏请求：θ(n²)

### 2.2-3
1. 平均需要查找 n/2 个元素
2. n
3. 平均情况θ(n) 最坏情况 θ(n)


## 2.3
![](https://raw.githubusercontent.com/Oliver59/IntroductionToAlgorithms/master/%E7%BB%83%E4%B9%A0/Image/2.3.png)

## 2.3-1
![](https://raw.githubusercontent.com/Oliver59/IntroductionToAlgorithms/master/%E7%BB%83%E4%B9%A0/Image/2.3-1.png)

## 2.3-2
```
MERGE(A,p,q,r)
	n1 = q - p  + 1
	n2 = r - q
	L = new integer[n1]
	R = new integer[n2]
	for i=1 to n1
		L[i]=A[p+i-1]
	for i=1 to n1
		R[i]=A[q+i]
	i = j = 1
	for k=p to r
		if i > n1 //说明数组L空了，需要将R数组中剩下的元素复制到数组A
			A[K] = R[j]
			j = j + 1
		else if j > n2//说明数组R空了，需要将L数组中剩下的元素复制到数组A
			A[k] = L[i]
			i = i + 1
		else//L、R数组都没有空
			if L[i] <= R[j] 
				A[k] = L[i]
				i = i + 1
			else
				A[K] = R[j]
				j = j + 1
```
## 2.3-3
## 2.3-4
## 2.3-5
伪代码
```
MERGE-FIND(A,begin,end,v)
	if begin == end
		if A[begin]==v
			return begin
		else 
			return NIL

	index = (end + begin)/2
	if A[index] > v
		return MERGE-FIND(A,begin,index-1,v)
	else if A[index] < v
		return MERGE-FIND(A,index,begin+1,v)
	else 
		return index
```

C# Code
```csharp
static void Main(string[] args)
{
    int[] A = new int[] { 1, 4, 7, 8, 10, 33 };
    Console.WriteLine(MERGE_FIND(A, 0, A.Length - 1, 6));
    Console.Read();
}


static int MERGE_FIND(int[] A, int begin, int end, int v)
{
    Console.Write($"begin:{begin}\t end:{end}\t");
    if (begin == end)
    {
        if (A[begin] == v)
            return begin;
        else
            return -1;
    }

    var index = (end + begin) / 2;
    Console.WriteLine($"index:{index}");
    if (A[index] > v)
        return MERGE_FIND(A, begin, index - 1, v);
    else if (A[index] < v)
        return MERGE_FIND(A, index + 1, end, v);
    else
        return index;
}
    
```
## 2.3-6
答：不能，因为即便缩短了查找的速度，但是还是需要将比它大的元素依次向后移动，这在最坏去情况下是线性的。
## 2.3-7
伪代码：
```
EXIST_PAIR(S,x)
	S = MARGE-SORT(S)//先用归并排序 复杂度为θ(nlogn)
	for i=1 to S.Length
		if MERGE-FIND(S,0,S.Length-1,x-S[i]) != NIL//通过二分法查找是否存在一个值为 x-S[i] 如果存在则说明包含
			return true
	return false
```
C# Code
```csharp

static void Main(string[] args)
{
    int[] S = new int[] { 3, 41, 52, 26, 57, 9, 49 };
    Console.WriteLine(EXIST_PAIR(S, 52));
    Console.Read();
}


/// <summary>
/// 在集合S中是否存在一对数，它们的和为x
/// </summary>
/// <param name="S"></param>
/// <param name="x"></param>
/// <returns></returns>
static bool EXIST_PAIR(int[] S, int x)
{
    S = MARGE_SORT(S, 0, S.Length - 1);

    Console.WriteLine(string.Join(",", S));

    for (int i = 0; i < S.Length; i++)
    {
        if (MERGE_FIND(S, 0, S.Length - 1, x - S[i]) != -1)
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// 二分法查找一个数
/// </summary>
/// <param name="A">要查找的数组</param>
/// <param name="begin">开始位置</param>
/// <param name="end">结束位置</param>
/// <param name="v">查找的字符</param>
/// <returns></returns>
static int MERGE_FIND(int[] A, int begin, int end, int v)
{
    //Console.WriteLine($"\r\nbegin:{begin}\t end:{end}\t");
    if (begin == end)
    {
        if (A[begin] == v)
            return begin;
        else
            return -1;
    }

    var index = (end + begin) / 2;
    //Console.WriteLine($"index:{index}");
    if (A[index] > v)
        return MERGE_FIND(A, begin, index - 1, v);
    else if (A[index] < v)
        return MERGE_FIND(A, index + 1, end, v);
    else
        return index;
}

/// <summary>
/// 归并排序
/// </summary>
/// <param name="A"></param>
/// <param name="p"></param>
/// <param name="r"></param>
/// <returns></returns>
static int[] MARGE_SORT(int[] A, int p, int r)
{
    if (p < r)
    {
        int q = (p + r) / 2;
        A = MARGE_SORT(A, p, q);
        A = MARGE_SORT(A, q + 1, r);
        return MARGE(A, p, q, r);
    }
    return A;
}
static int[] MARGE(int[] A, int p, int q, int r)
{
    int n1 = q - p + 1;
    int n2 = r - q;
    int[] L = new int[n1 + 1];
    int[] R = new int[n2 + 1];

    int i;
    int j;

    for (i = 0; i < n1; i++)
    {
        L[i] = A[i + p];
    }
    L[n1] = int.MaxValue;

    for (i = 0; i < n2; i++)
    {
        R[i] = A[i + q + 1];
    }
    R[n2] = int.MaxValue;

    i = 0;
    j = 0;
    for (int k = p; k <= r; k++)
    {
        if (L[i] <= R[j])
        {
            A[k] = L[i];
            i++;
        }
        else
        {
            A[k] = R[j];
            j++;
        }
    }
    return A;
}
```